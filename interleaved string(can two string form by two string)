dp = [[0]*101]*101

# This function checks if there exist a valid path from 0,0 to n,m
def dfs(i, j, A, B, C):

    # If path has already been calculated from this index
    # then return calculated value.
    if(dp[i][j]!=-1):
        return dp[i][j]
        
    # If we reach the destination return 1
    n,m=len(A),len(B)
    if(i==n and j==m):
        return 1
    
    # If C[i+j] matches with both A[i] and B[j]
    # we explore both the paths
    
    if (i<n and A[i]==C[i + j] and j<m and B[j]==C[i + j]):
        # go down and store the calculated value in x
        # and go right and store the calculated value in y.
        x = dfs(i + 1, j, A, B, C)
        y = dfs(i, j + 1, A, B, C)
        
        # return the best of both.
        dp[i][j] = x or y
        return dp[i][j]
    
    # If C[i+j] matches with A[i].
    if (i < n and A[i] == C[i + j]):
        # go down
        x = dfs(i + 1, j, A, B, C)
        
        # Return the calculated value.
        dp[i][j] = x
        return dp[i][j]
    
    # If C[i+j] matches with B[j].
    if (j < m and B[j] == C[i + j]):
        y = dfs(i, j + 1, A, B, C)
        
        # Return the calculated value.
        dp[i][j] = y
        return dp[i][j]
    
    # if nothing matches we return 0
    dp[i][j] = 0
    return dp[i][j]
