

#tabulation

def equalPartition(self, n, nums):
    s = sum(nums)
    if s % 2 != 0:
        return False
    s = int(s / 2)
    numsLen = len(nums)
    dp = [[False for _ in range(int(s) + 1)] for _ in range(numsLen)]
    for i in range(numsLen):
        dp[i][0] = True
    for j in range(1, s + 1):
        dp[0][j] = nums[0] == j
    for i in range(1, numsLen):
        for j in range(1, s + 1):
            nottake = dp[i - 1][j]
            take = False
            if j >= nums[i]:  
                take = dp[i - 1][j - nums[i]]
            dp[i][j] = take or nottake
    return dp[numsLen-1][s]

#memoization
// take and not-take

if sum(arr)%2 == 1:
    return False
else:
    memo = {}
    def helper(indx,target):
        if (indx,target) in memo:
            return memo[(indx,target)]
        if target == 0:
            return True
        if indx == 0:
            return (arr[0] == target)
        nottake = helper(indx-1,target)
        take = False
        if arr[indx] <= target:
            take = helper(indx-1,target - arr[indx])
        memo[(indx,target)] = take or nottake
        return memo[(indx,target)] 
    return helper(len(arr)-1,k)
